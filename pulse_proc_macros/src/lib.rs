extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn::{Data, DeriveInput, Error, Fields, Type, parse_macro_input};

/// Implements parts of the Runnable trait for a Reporter struct.
///
/// This macro automatically generates the `run` and `name` methods for the Runnable trait.
/// It requires the annotated struct to have the following fields:
/// - `name: String`
/// - `broker: Weak<Broker>` (Note: This field is currently required but not directly used by the generated code)
/// - `report_rx: ReportReceiver`
///
/// The user MUST manually implement `Runnable::new` for the struct, ensuring
/// these fields (and any others) are correctly initialized.
/// The struct must also implement the `Executor` trait.
///
/// # Example
///
/// ```rust,ignore
/// use pulse_proc_macros::reporter;
/// use crate::broker::{Broker, ReportReceiver};
/// use crate::message::EndpointHistory;
/// use crate::runnable::Runnable;
/// use crate::agent::reporter::Executor;
/// use std::sync::Weak;
/// use anyhow::Result;
///
/// #[reporter]
/// struct MyReporter {
///     name: String,
///     broker: Weak<Broker>,
///     report_rx: ReportReceiver,
///     // ... other fields like stdout ...
/// }
///
/// #[async_trait::async_trait]
/// impl Runnable for MyReporter {
///     fn new(id: usize, broker: Weak<Broker>) -> Result<Self> {
///         if let Some(broker_arc) = broker.upgrade() {
///             let report_rx = broker_arc.register_report_receiver();
///             Ok(Self {
///                 name: format!("my-reporter-{}", id),
///                 broker, // Store the weak ref
///                 report_rx,
///                 // ... initialize other fields ...
///             })
///         } else {
///             anyhow::bail!("Broker not alive")
///         }
///     }
///     // name() and run() are generated by #[reporter]
/// }
///
/// impl MyReporter {
///     // Implementation for the Executor trait
///     async fn report(&mut self, report: EndpointHistory) {
///         // Your custom reporting logic here
///     }
/// }
/// ```
///
/// # Errors
///
/// This macro will emit a compile error if:
/// - The annotated item is not a struct with named fields.
/// - The struct doesn't have a `name` field of type String.
/// - The struct doesn't have a `broker` field of type Weak<Broker>.
/// - The struct doesn't have a `report_rx` field of type ReportReceiver.
#[proc_macro_attribute]
pub fn reporter(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // Parse the input tokens into a syntax tree
    let input = parse_macro_input!(item as DeriveInput);

    // Get the name of the struct
    let struct_name = &input.ident;

    // Verify that we're dealing with a struct
    let fields = match &input.data {
        Data::Struct(data_struct) => match &data_struct.fields {
            Fields::Named(fields_named) => &fields_named.named,
            _ => {
                return TokenStream::from(
                    Error::new_spanned(
                        struct_name,
                        "reporter attribute can only be applied to structs with named fields",
                    )
                    .to_compile_error(),
                );
            }
        },
        _ => {
            return TokenStream::from(
                Error::new_spanned(
                    struct_name,
                    "reporter attribute can only be applied to structs",
                )
                .to_compile_error(),
            );
        }
    };

    // Check if the struct has the required fields
    let mut has_name = false;
    let mut has_broker = false;
    let mut has_report_rx = false;

    for field in fields {
        if let Some(ident) = &field.ident {
            let type_str = type_to_string(&field.ty);
            if ident == "name" {
                if type_str.contains("String") {
                    has_name = true;
                } else {
                    return TokenStream::from(
                        Error::new_spanned(
                            &field.ty,
                            "reporter requires 'name' field to be String",
                        )
                        .to_compile_error(),
                    );
                }
            } else if ident == "broker" {
                if type_str.contains("Weak") && type_str.contains("Broker") {
                    has_broker = true;
                } else {
                    return TokenStream::from(
                        Error::new_spanned(
                            &field.ty,
                            "reporter requires 'broker' field to be Weak<Broker>",
                        )
                        .to_compile_error(),
                    );
                }
            } else if ident == "report_rx" {
                // Allow flexibility in naming, e.g., ReportReceiver or broker::ReportReceiver
                if type_str.contains("ReportReceiver") {
                    has_report_rx = true;
                } else {
                    return TokenStream::from(
                        Error::new_spanned(
                            &field.ty,
                            "reporter requires 'report_rx' field to be ReportReceiver",
                        )
                        .to_compile_error(),
                    );
                }
            }
        }
    }

    if !has_name {
        return TokenStream::from(
            Error::new_spanned(struct_name, "reporter requires a 'name' field").to_compile_error(),
        );
    }

    if !has_broker {
        return TokenStream::from(
            Error::new_spanned(
                struct_name,
                "reporter requires a 'broker' field of type Weak<Broker>",
            )
            .to_compile_error(),
        );
    }

    if !has_report_rx {
        return TokenStream::from(
            Error::new_spanned(struct_name, "reporter requires a 'report_rx' field")
                .to_compile_error(),
        );
    }

    // Generate the implementation of the relevant parts of the Runnable trait
    let expanded = quote! {
        #input

        #[async_trait::async_trait]
        impl crate::runnable::Runnable for #struct_name {
            // User must implement `fn new(...) -> Result<Self>`

            // Generate the `run` method using `self.report_rx`
            async fn run(&mut self) {
                loop {
                    // Assuming ReportReceiver is tokio::sync::broadcast::Receiver
                    match self.report_rx.receive().await {
                        Ok(report) => {
                            // Call the Executor trait's report method
                            <Self as crate::agent::reporter::executor::Executor>::report(self, report).await;
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                            tracing::info!("[reporter] {} detected report channel closed. Stopping...", self.name());
                            break; // Channel closed
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Lagged(n)) => {
                             tracing::warn!("[reporter] {} report receiver lagged by {} messages.", self.name(), n);
                            // Decide whether to continue or break on lag
                        }
                    }
                }
            }

            // Generate the `name` method
            fn name(&self) -> &str {
                &self.name
            }
        }

        // Compile-time check to ensure the struct implements Executor
        const _: fn() = || {
            fn assert_executor<T: crate::agent::reporter::executor::Executor>() {}
            assert_executor::<#struct_name>();
        };
    };

    // Convert back to a token stream and return it
    TokenStream::from(expanded)
}

// Helper function to convert syn::Type to String for basic checking
fn type_to_string(ty: &Type) -> String {
    quote!(#ty).to_string().replace(' ', "") // Remove spaces for easier comparison
}
